// LAPIZ
Lapiz = (function() {
      "use strict";

      var win = window,
        idCounter = 0;

      return function() {

          var lapiz = {},
            utils = {};

          utils.updateWindow = function() {
            lapiz.windowWidth = window.innerWidth;
            lapiz.windowHeight = window.innerHeight;
          };
          utils.updateWindow();

          lapiz.id = idCounter++;

          //-------------------------------------

          //@prepros-append lapiz/_canvas.js

          //@prepros-append lapiz/_style.js
          
          //@prepros-append lapiz/_image.js

          //@prepros-append lapiz/_draw.js

          //@prepros-append lapiz/_shape.js

          //@prepros-append lapiz/_steps.js
          //@prepros-append lapiz/_events.js

          //------------------------------------

         


          //@prepros-append lapiz/end.js

/* CANVAS *****************************/
lapiz.ctx = null;

lapiz.canvas = {
	node:null,
	ctx:null,
	width:0,
	height:0,
	select:function(id_or_node){
		if(typeof id_or_node === 'string'){
			var cnv = document.getElementById(id_or_node);
		}else{
			var cnv = id_or_node;
		}
		
		this.node = cnv;
		this.width = cnv.width;
		this.height = cnv.height;
		this.centerX = Math.round(cnv.width/2);
		this.centerY = Math.round(cnv.height/2);
		lapiz.ctx = cnv.getContext('2d');
		return lapiz;
	},
	create:function(width,height,context){
		var cont = context || document.body;
		var cnv = document.createElement('canvas');
		cnv.width = width;
		cnv.height = height;
		cont.appendChild(cnv);

		this.select(cnv);
		return lapiz;
	}
};

/* end CANVAS *****************************/
/* STYLE *****************************/

var strokeWidth = 1;

var idFillCounter = 1,
	currentFill = {
		id: 0,
		type: 'color',
		value: '#000'
	},
	updateFill = function(f) {

		if (f.id === currentFill.id) {
			lapiz.style.fill(f);
		}
	};


lapiz.style = {
	fill: function(v) {
		if (typeof v === 'string') {
			lapiz.ctx.fillStyle = v;
			currentFill = lapiz.style.createColor(v);
		} else {
			console.log(v);
			lapiz.ctx.fillStyle = v.value;
			currentFill = v;
		}
		return lapiz.style;
	},
	stroke: function(v) {

		if (typeof v === 'string') {
			lapiz.ctx.strokeStyle = v;
		} else {

		}
		return lapiz.style;
	},
	strokeWidth: function(v) {
		strokeWidth = parseFloat(v);
		lapiz.ctx.lineWidth = strokeWidth;

		return lapiz.style;
	},
	createColor:function(str){
		var c = str || '#000';

		var color = {
			id: idFillCounter++,
			type: 'color',
			value : c,
			get val() {
				return this.value;
			},
			set val(val) {
				this.value = val;
				updateFill(this);
			}
		}
		return color;
	},
	createPattern: function(imageName, repeat, x, y) {
		var repeat = repeat || 'repeat',
			x = x || 0,
			y = y || 0,
			create = function(imageName,repeat){
				return lapiz.ctx.createPattern(imageBuffer[imageName],repeat);
			},
			pattern = create(imageName,repeat);

		var pat = {
			id: idFillCounter++,
			type: 'pattern',
			value:pattern,
			imageName: imageName,
			repeatValue: repeat,
			xOffset: x,
			yOffset: y,
			get image() {
				return this.imageName;
			},
			set image(val) {
				this.imageName = val;
				this.value = create(this.imageName,this.repeatValue);
				updateFill(this);
			},
			get repeat() {
				return this.repeatValue;
			},
			set repeat(val) {
				this.repeatValue = val;
				this.value = create(this.imageName,this.repeatValue);
				updateFill(this);
			},
			get x() {
				return this.xOffset;
			},
			set x(val) {
				this.xOffset = val;
				updateFill(this);
			},
			get y() {
				return this.yOffset;
			},
			set y(val) {
				this.yOffset = val;
				updateFill(this);
			}
		}
		return pat;
	}
}
/* IMAGE *****************************/

var imageBuffer = {};

lapiz.image = {
	load: function(name, url) {

		imageBuffer[name] = null;

		var img = new Image();

		img.src = url;
		
		utils.on(img,'load error',function(){
			imageBuffer[name] = img; 
		});
	
		return lapiz.image;
	},
	get:function(name){
		return imageBuffer[name];
	}
};

/* end IMAGE *****************************/
/* DRAW *****************************/
lapiz.draw = {
	beginPath: function() {
		lapiz.ctx.beginPath();
		return lapiz.draw;
	},
	closePath: function() {
		lapiz.ctx.closePath();
		return lapiz.draw;
	},
	fill: function() {
		lapiz.ctx.fill();
		return lapiz.draw;
	},
	stroke: function() {
		if(strokeWidth > 0){
			lapiz.ctx.stroke();
		}		
		return lapiz.draw;
	},
	moveTo: function(x,y) {
		lapiz.ctx.moveTo(x,y);
		return lapiz.draw;
	},
	lineTo: function(x,y) {
		lapiz.ctx.lineTo(x,y);
		return lapiz.draw;
	},
	arcTo: function(x1,y1,x2,y2,radius) {
		lapiz.ctx.arcTo(x1,y1,x2,y2,radius);
		return lapiz.draw;
	},
	quadraticCurveTo: function(xp,yp,x,y) {
		lapiz.ctx.quadraticCurveTo(xp,yp,x,y);
		return lapiz.draw;
	},
	bezierCurveTo: function(xp1,yp1,xp2,yp2,x,y) {
		lapiz.ctx.bezierCurveTo(xp1,yp1,xp2,yp2,x,y);
		return lapiz.draw;
	},
	arc: function(x,y,startAngle,endAngle,anticlockwise) {
		lapiz.ctx.arc(x,y,startAngle,endAngle,anticlockwise);
		return lapiz.draw;
	},
	rect: function(x,y,w,h) {
		lapiz.ctx.rect(x,y,w,h);
		return lapiz.draw;
	},
	isPointInPath: function(x,y) {
		return lapiz.ctx.isPointInPath(x,y);
	}
}

/* end DRAW *****************************/
/* SHAPE *****************************/
var PI = Math.PI,
	halfPI = 0.5 * Math.PI,
	twoPI = 2 * Math.PI;

lapiz.shape = {
	rectangle: function(x, y, w, h) {
		var x = x || lapiz.canvas.centerX - 80,
			y = y || lapiz.canvas.centerY - 50,
			w = w || 160,
			h = h || 100;

		lapiz.draw
			.beginPath()
			.rect(x, y, w, h)
			.closePath()
			.fill()
			.stroke();
		return lapiz.shape;
	},
	square: function(x, y, w) {
		var x = x || lapiz.canvas.centerX - 50,
			y = y || lapiz.canvas.centerY - 50,
			w = w || 100;
		return lapiz.shape.rectangle(x, y, w, w);
	},
	rectangleRounded: function(x, y, w, h, r, r2, r3, r4) {
		var x = x || lapiz.canvas.centerX - 80,
			y = y || lapiz.canvas.centerY - 50,
			w = w || 160,
			h = h || 100,
			r1 = r || 20,
			r2 = r2 || r1,
			r3 = r3 || r1,
			r4 = r4 || r1;

		lapiz.draw
			.beginPath()
			.moveTo(x, y + r1)
			.arcTo(x, y, x + r1, y, r1)
			.lineTo(x + w - r2, y)
			.arcTo(x + w, y, x + w, y + r2, r2)
			.lineTo(x + w, y + h - r3)
			.arcTo(x + w, y + h, x + w - r3, y + h, r3)
			.lineTo(x + r4, y + h)
			.arcTo(x, y + h, x, y + h - r4, r4)
			.lineTo(x, y + r1)
			.closePath()
			.fill()
			.stroke();
		return lapiz.shape;
	},
	circle: function(x, y, r) {
		var x = x || lapiz.canvas.centerX,
			y = y || lapiz.canvas.centerY,
			r = r || 40;

		lapiz.draw
			.beginPath()
			.arc(x, y, r, 0, twoPI, false)
			.closePath()
			.fill()
			.stroke();
		return lapiz.shape;
	},
	ellipse: function(x, y, w, h) {
		var x = x || lapiz.canvas.centerX,
			y = y || lapiz.canvas.centerY,
			w = w || 160,
			h = h || 80,
			r = 3.7;
		var curve = [{
			cp1: {
				x: x - w / 2,
				y: y - h / r
			},
			cp2: {
				x: x - w / r,
				y: y - h / 2
			},
			p: {
				x: x,
				y: y - h / 2
			}
		}, {
			cp1: {
				x: x + w / r,
				y: y - h / 2
			},
			cp2: {
				x: x + w / 2,
				y: y - h / r
			},
			p: {
				x: x + w / 2,
				y: y
			}
		}, {
			cp1: {
				x: x + w / 2,
				y: y + h / r
			},
			cp2: {
				x: x + w / r,
				y: y + h / 2
			},
			p: {
				x: x,
				y: y + h / 2
			}
		}, {
			cp1: {
				x: x - w / r,
				y: y + h / 2
			},
			cp2: {
				x: x - w / 2,
				y: y + h / r
			},
			p: {
				x: x - w / 2,
				y: y
			}
		}];

		lapiz.draw
			.beginPath()
			.moveTo(curve[3].p.x, curve[3].p.y);

		for (var i = 0; i < 4; i++) {
			lapiz.draw
				.bezierCurveTo(curve[i].cp1.x, curve[i].cp1.y, curve[i].cp2.x, curve[i].cp2.y, curve[i].p.x, curve[i].p.y);
		}
		lapiz.draw
			.closePath()
			.fill()
			.stroke();
		return lapiz.shape;
	},
	polygon: function(x, y, r, s, a) {
		var x = x || lapiz.canvas.centerX,
			y = y || lapiz.canvas.centerY,
			r = r || 60,
			s = s || 5,
			a = a || 0;
		var sideAngle = twoPI / s;
		lapiz.draw
			.beginPath()
			.moveTo(x +  r * Math.sin(a+PI), y +  r *  Math.cos(a+PI));
		for (var i = 0; i < s; i++) {
			lapiz.draw
				.lineTo(x +  r * Math.sin(i * sideAngle + a+PI), y +  r *  Math.cos(i * sideAngle + a+PI));
		}

		lapiz.draw
			.closePath()
			.fill()
			.stroke();
		return lapiz.shape;
	},
	triangle:function(x, y, r, a){
		var x = x || lapiz.canvas.centerX,
			y = y || lapiz.canvas.centerY,
			r = r || 60,
			a = a || 0;
		return lapiz.shape.polygon(x, y, r, 3, a) ;
	},
	line:function(x1,y1,x2,y2){
		var x1 = x1  || lapiz.canvas.centerX - 50,
			y1 = y1  || lapiz.canvas.centerY,
			x2 = x2  || lapiz.canvas.centerX + 50,
			y2 = y2  || lapiz.canvas.centerY;

		lapiz.draw
			.beginPath()
			.moveTo(x1,y1)
			.lineTo(x2,y2)
			.closePath()
			.stroke();
		return lapiz.shape;
	},
	lineHorizontal:function(x,y,w){
		var x = x || lapiz.canvas.centerX - 50,
			y = y  || lapiz.canvas.centerY,
			w = w || 100,
			x2 = x + w,
			y2 = y;
			
		return lapiz.shape.line(x,y,x2,y2);
	},
	lineVertical:function(x,y,h){
		var x = x || lapiz.canvas.centerX,
			y = y  || lapiz.canvas.centerY - 50,
			h = h || 100,
			x2 = x,
			y2 = y + h;
			
		return lapiz.shape.line(x,y,x2,y2);
	},
	path:function(str){
		return lapiz.shape;
	}

}

/* end SHAPE *****************************/
/* STEPS *****************************/

var onAllLoaded = function(handler) {
	var timerWaitToLoad = setInterval(function() {
		var allImagesLoaded = true;
		for (var a in imageBuffer) {
			if (imageBuffer[a] === null) {
				allImagesLoaded = false;
			}
		}
		if (allImagesLoaded) {
			handler();
			clearInterval(timerWaitToLoad);
		}
	}, 60);
};

var waitPreload = false;

lapiz.preload = function(callback) {
	waitPreload = true;
	callback.apply(lapiz, []);
	return lapiz;
};

var waitSetup = false;

lapiz.setup = function(callback) {
	waitSetup = true;
	if (waitPreload) {
		onAllLoaded(function() {
			waitPreload = false;
			callback.apply(lapiz, []);
			waitSetup = false;
		});
	} else {
		callback.apply(lapiz, []);
		waitSetup = false;
	}
	return lapiz;
};

window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
	return setTimeout(f, 1000 / 60)
}

lapiz.render = function(callback) {

	var frameFunction = function() {
		callback.apply(lapiz, []);
		requestAnimationFrame(frameFunction);
	};

	if (waitPreload && !waitSetup) {
		onAllLoaded(function() {
			waitPreload = false;
		});
	}

	var timerWaitToRender = setInterval(function() {
		if (!waitPreload && !waitSetup) {
			frameFunction();
			clearInterval(timerWaitToRender);
		}
	}, 60);

	return lapiz;
}

/* end STEPS *****************************/
/* EVENTS *****************************/

utils.on = function(eventTarget, eventType, eventHandler){
	var arrayEvents = eventType.split(' ');
	for(var i = 0; i<arrayEvents.length;i++){
		eventTarget.addEventListener(arrayEvents[i], eventHandler,false);
	}	
};

// window events
lapiz.onResize = function(eventHandler){
	utils.on(window,'resize',eventHandler);
	return lapiz;
}
lapiz.onResize(utils.updateWindow);


for (var a in lapiz) {
	if (typeof lapiz[a] == 'object' && lapiz[a] !== null) {
		lapiz[a].and = function() {
			return lapiz;
		}
	}
}
lapiz.and = function() {
	return lapiz;
}


return lapiz;
}
})();
